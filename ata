#!/usr/bin/env perl
use Mojolicious::Lite;
use Mojo::Util qw/trim/;
use v5.20;
use FindBin;
use experimental 'signatures';

use lib "$FindBin::Bin/lib";
use Atat::Objects;

plugin AssetPack => {
    pipes => [qw/Sass Css Combine/]
};

app->asset->process(
  'ata.css' => (
    "https://www.w3schools.com/w3css/4/w3.css",
    "https://fonts.googleapis.com/css?family=Raleway",
"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css",
    "scss/skel.scss",
  )
);

my @pages = qw/
  login
  select_bucket
  create_bucket
  create_user
  manage_roles
  enter_loa
  access_cloud
  reconcile
  reports
  logout
  /;

my %labels = (
  login        => 'Login',
  create_user  => "Add a new AT-AT user",
  manage_roles => 'Manage roles',
  select_bucket  => 'Select funding pool',
  create_bucket  => 'Create funding pool',
  enter_loa    => 'Add an LOA',
  access_cloud => 'Access the cloud!',
  reconcile    => 'Reconcile invoices',
  reports      => 'Run reports',
  logout       => 'Logout'
);

app->defaults(pages => \@pages, labels => \%labels, layout => 'default',);

# Permissions are based on bucket + role.

my %perms;     # user => bucket->id => role => 1
my %buckets;   # bucket->id => bucket

app->helper(
  perms => sub($c) {
    \%perms;
  }
);

app->helper(user => sub($c) { $c->session('user'); });
app->helper(
  bucket => sub($c) {
    my $id = $c->session('bucket') or return '';
    return $buckets{$id} if exists($buckets{$id});
    $c->session('bucket', '');
    return '';
  }
);

app->helper(
  users => sub($c) {
    keys %perms;
  }
);

app->helper(
  roles => sub($c) {
    (grep { $_ !~ /^(login|logout)$/ } @pages), 'cac', 'mfa';
  }
);

# Check perms for a user
app->helper(
  check_perms => sub ($c, $user, $role) {

    # Unchangeable
    for ($role) {
      /login/  and return !$user;
      /logout/ and return 1;
    }

    # Defaults if no bucket is selected
    my $bucket = $c->bucket or app->log->debug("no bucket");
    unless ($bucket) {
      for ($role) {
        /create_bucket/ and return !!$user;
        /select_bucket/ and return !!$user;
      }
      return 0;
    }

    # Explicitly set.
    return 0 unless $user;
    app->log->debug("checking perms for user $user");
    if (exists($perms{$user}{$bucket->id}{$role})) {
      return $perms{$user}{$bucket->id}{$role};
    }

    # Fallbacks.
    for ($role) {
      /create_bucket/ and return !!$user;
      /select_bucket/ and return !!$user;
    }

    return 0;
  }
);

# Check perms for the logged in user.
app->helper(
  user_can => sub ($c, $role) {
    return $c->check_perms($c->user, $role);
  }
);

app->helper(
  users_buckets => sub($c) {
    my $grant = $perms{$c->user} or return;
    sort keys %$grant;
  }
);

app->helper(
  add_bucket => sub ($c, $bucket) {
    my $id = $bucket->id;
    $buckets{$id}                         = $bucket;
    $perms{$c->user}{$id}{'manage_roles'} = 1;
    $perms{$c->user}{$id}{'create_user'}  = 1;
  }
);

app->helper(
  select_bucket => sub ($c, $id) {
    $c->app->log->debug("Switching to bucket " . $c->dumper($b));
    $c->session(bucket => $id);
  }
);

app->helper(
  error => sub ($c, $msg) {
    $c->flash(msg => $msg);
    $c->redirect_to($c->current_route);
  }
);

app->helper(
  unauthorized => sub($c) {
    $c->render(status => 403, inline => <<DONE );
unauthorized
<br>
%= link_to 'home' => 'dashboard'
DONE
  }
);

# Public routes
get '/' => sub($c) {
  $c->render;
} => 'dashboard';

get '/login';
get '/logout' => sub($c) {
  $c->session(user    => '');
  $c->session(bucket  => '');
  $c->session(expires => 1);
};


post '/login' => sub($c) {
  unless ($c->req->param('username')) {
    $c->flash(msg => 'missing username');
    return $c->redirect_to('login');
  }
  $c->session('user', $c->req->param('username'));
  $c->redirect_to('login');
};

# Private routes
under sub($c) {
  $c->app->log->debug($c->dumper(\%perms));
  my $user = $c->user or return $c->unauthorized;
  my $role = $c->current_route;
  $c->app->log->debug("checking auth for $user to perform $role");
  return $c->unauthorized unless $c->user_can($role);
  1;
};

get '/select_bucket' => sub($c) {
  $c->select_bucket($c->param('bucket')) if $c->param('bucket');
};
get '/manage_roles';
get '/create_user';
get '/create_bucket';
get '/enter_loa';
get '/access_cloud';
get '/reconcile';
get '/reports';

post '/manage_roles' => sub($c) {
  for my $user ($c->users) {
    for my $role ($c->roles) {
      app->log->debug("setting $user @{[ $c->bucket->id ]} $role to "
          . !!$c->param("$user\_$role"));
      $perms{$user}{$c->bucket->id}{$role} = !!$c->param("$user\_$role");
    }
  }
  $c->flash(msg => "Saved changes");
  $c->redirect_to('manage_roles');
};

post '/create_user' => sub($c) {
  my $user = $c->param('name');
  $perms{$user}{$c->bucket->id} = {} if $c->bucket;
  $c->flash(msg => "Added user $user");
  $c->redirect_to('manage_roles');
};

post '/create_bucket' => sub($c) {
  # TODO: more than just task order.
  my $number = trim($c->param('task_number')) or return $c->error('missing task number');
  my $type = trim($c->param('bucket_type')) or return $c->error('missing type');
  my $name = trim($c->param('name')) or return $c->error('missing name');
  my $id = $number;
  return "Task $id already exists" if exists($buckets{$id});
  my $b = TaskOrder->new(id => $id, type => $type, name => $name);
  $c->add_bucket($b);
  $c->select_bucket($id);
  $c->redirect_to('select_bucket');
};

app->start unless caller eq 'main';
